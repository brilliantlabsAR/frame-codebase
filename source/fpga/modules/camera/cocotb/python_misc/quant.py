import numpy as np
import sys, os

from dct_aan import aan_scale_factors_2d
#import dct


qt_luma = np.array([
    [16,11,10,16,24,40,51,61],
    [12,12,14,19,26,48,60,55],
    [14,13,16,24,40,57,69,56],
    [14,17,22,29,51,87,80,62],
    [18,22,37,56,68,109,103,77],
    [24,35,55,64,81,104,113,92],
    [49,64,78,87,103,121,120,101],
    [72,92,95,98,112,100,103,99]])

qt_chroma = np.array([
    [17,18,24,47,99,99,99,99],
    [18,21,26,66,99,99,99,99],
    [24,26,56,99,99,99,99,99],
    [47,66,99,99,99,99,99,99],
    [99,99,99,99,99,99,99,99],
    [99,99,99,99,99,99,99,99],
    [99,99,99,99,99,99,99,99],
    [99,99,99,99,99,99,99,99]])
                         

def qt_scale(qt, qf=50, qd=None):
    """
    Q-table scaler
    Usage: 
        qt_scale(qt_luma, qf=100) / aan_scale_factors_2d
        OR
        qt_scale(qt_luma, qf=100, qd=aan_scale_factors_2d)
    """
    if qd is None:
        qd = np.ones(qt.shape)
    
    if qf < 50:
        scale = 5000/qf
    else:
        scale = 200 - 2*qf  # 2 - qf/50

    t = np.floor((scale*qt + 50) / 100); 
    t[t < 1] = 1   # Prevent divide by 0 error 
    t /= qd
    return t

def qt_scale_log(qt, qf_log=0, qd=None):
    """
    Q-table scaler logarithmic qf=50 -> qfl=0
    Usage: 
        qt_scale(qt_luma, qf_log=0) / aan_scale_factors_2d
        OR
        qt_scale(qt_luma, qf_log=0, qd=aan_scale_factors_2d)
    """
    if qd is None:
        qd = np.ones(qt.shape)
    
    scale = 2**qf_log
    
    # reverse calcuclate qf for reference
    if qf_log >= 0:
        qf = 50/scale
    else:
        qf = 100 - 50*scale
    
    t = np.floor(scale*qt + 0.5); 
    t[t < 1] = 1   # Prevent divide by 0 error 
    t /= qd
    return t


# From https://medium.com/100-days-of-algorithms/day-63-zig-zag-51a41127f31
def zig_zag_index(k, n=8):
    # upper side of interval
    if k >= n * (n + 1) // 2:
        i, j = zig_zag_index(n * n - 1 - k, n)
        return n - 1 - i, n - 1 - j
    # lower side of interval
    i = int((np.sqrt(1 + 8 * k) - 1) / 2)
    j = k - i * (i + 1) // 2
    return (j, i - j) if i & 1 else (i - j, j)

# From https://medium.com/100-days-of-algorithms/day-63-zig-zag-51a41127f31
def zig_zag_value(i, j, n=8):
    # upper side of interval
    if i + j >= n:
        return n * n - 1 - zig_zag_value(n - 1 - i, n - 1 - j, n)
    # lower side of interval
    k = (i + j) * (i + j + 1) // 2
    return k + i if (i + j) & 1 else k + j
    
    
def zig_zag_array():
    M = np.empty((8, 8), dtype=int)
    for i in range(8):
        for j in range(8):
            M[i, j] = zig_zag_value(i, j)
    return M
        
def de_zig_zag_array():
    M = np.empty((64), dtype=int)
    for i in range(8):
        for j in range(8):
            M[zig_zag_value(i, j)] = 8*i+j
    return M
        
    
    
    
class QTables:
    def __init__(self, qf=50, qf_log=None):
        self.aan_scale = aan_scale_factors_2d
        self.bits = 13

        self.qf = qf
        self.qf_log = qf_log

        self.qt_luma = qt_scale(qt_luma, self.qf)
        self.qt_luma_aan = qt_scale(qt_luma, self.qf, qd=self.aan_scale)
        self.qt_luma_aan_factors = 1/self.qt_luma_aan
        self.qt_luma_aan_factors_bin = np.floor((2**(self.bits - 1))/self.qt_luma_aan + 0.5).astype(int)

        self.qt_chroma = qt_scale(qt_chroma, self.qf)
        self.qt_chroma_aan = qt_scale(qt_chroma, self.qf, qd=self.aan_scale)
        self.qt_chroma_aan_factors = 1/self.qt_chroma_aan
        self.qt_chroma_aan_factors_bin = np.floor((2**(self.bits - 1))/self.qt_chroma_aan + 0.5).astype(int)

    def get_vlog(self):
        x = []
        for y in range(8)[::-1]:
            x.append( ','.join([f'{i:5d}' for i in self.qt_chroma_aan_factors_bin[y][::-1]]))
        for y in range(8)[::-1]:
            x.append( ','.join([f'{i:5d}' for i in self.qt_luma_aan_factors_bin[y][::-1]]))
            
        x = ',\n'.join(x)    

        print (f'// chroma + luma ROMs autogenerated by {os.path.basename(__file__)}')
        print (f'initial mem = {{\n{x}\n}};')

    def quantize_luma(self, m, sel='scipy'):
        if sel == 'aan':
            return np.round(m/self.qt_luma_aan)
        return np.round(m/self.qt_luma)

    def quantize_chroma(self, m, sel='scipy'):
        if sel == 'aan':
            return np.round(m/self.qt_chroma_aan)
        return np.round(m/self.qt_chroma)
    



def get_qt_info(qf):
    qt = QTables(qf)
    print('-' * 79)
    print(f'Luma AAN scaling =\n{qt.aan_scale}\n')
    
    print('-' * 79)
    print(f'QF = {qt.qf}')
    print(f'Bits = {qt.bits}\n')

    print('-' * 79)
    print(f'Luma Q-table =\n{qt_luma}\n')
    print(f'Luma Q-table scaled =\n{qt.qt_luma}\n')
    print(f'Luma Q-table AAN adjusted =\n{qt.qt_luma_aan}\n')
    print(f'Luma Q-table AAN factors =\n{qt.qt_luma_aan_factors}\n')
    print(f'Luma Q-table AAN factors, {qt.bits}-bit =\n{qt.qt_luma_aan_factors_bin}\n')


    print('-' * 79)
    print(f'Chroma Q-table =\n{qt_chroma}\n')
    print(f'Chroma Q-table scaled =\n{qt.qt_chroma}\n')
    print(f'Chroma Q-table AAN adjusted =\n{qt.qt_chroma_aan}\n')
    print(f'Chroma Q-table AAN factors =\n{qt.qt_chroma_aan_factors}\n')
    print(f'Chroma Q-table AAN factors, {qt.bits}-bit =\n{qt.qt_chroma_aan_factors_bin}\n')
    

def get_qf_info():
    print('-' * 79)
    for n in range(-8,8):
        q = 50/2**n
        r = (200 - 100*2**n)/2
        p = q if n > 0 else r
        p = round(p, 1) #if abs(n)==7 else int(p + .5)
        print(f'QF = {p}  scale = 2^{n}')


if __name__ == '__main__':
    qf = 50
    #get_qt_info(qf)
    #get_qf_info()

    qt = QTables(qf)
    #qt.get_vlog()

#    M = np.empty((8, 8), dtype=int)
#    for k in range(64):
#        y,x = zig_zag_index(k)
#        #print(f'y={y} x={x}' ,k)
#        #print(f'{{{y},{x}}}: ' , f'{{{k}}}')
#        print(' '*8, f'{8*y+x:2d}: ',f'{k:2d};')
#    print(M)
    
    print (zig_zag_array())
